<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÏóòÏÇ¨ÎÑ§ ÏàòÎèô Ï†ÑÏõê Í≥†Ïä§ÌÜ± (Final: ÎªëÏùò ÎØ∏Ìïô)</title>
    <style>
        /* --- [Í∏∞Î≥∏ ÏÑ§Ï†ï] --- */
        body { 
            margin: 0; padding: 0; 
            background-color: #111; 
            height: 100vh; width: 100vw;
            display: flex; justify-content: center; align-items: center; 
            font-family: 'Malgun Gothic', sans-serif; 
            overflow: hidden; 
            user-select: none; 
            touch-action: none; 
        }

        #game-wrapper {
            position: relative;
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden;
        }

        #game-container { 
            width: 1500px; height: 720px; 
            display: flex; 
            box-shadow: 0 0 50px rgba(0,0,0,0.9); 
            position: absolute; 
            transform-origin: center center; 
        }

        .frame { width: 500px; height: 100%; position: relative; box-sizing: border-box; padding: 20px; display: flex; flex-direction: column; }
        .wood-bg { background: url('wood.jpg') no-repeat center center; background-size: cover; }
        .wood-bg-fallback { background-color: #5d4037; } 
        .green-bg { background-color: #004d00; border-left: 2px solid rgba(0,0,0,0.3); border-right: 2px solid rgba(0,0,0,0.3); }

        /* --- [Ïπ¥Îìú Ïä§ÌÉÄÏùº] --- */
        .card { 
            width: 70px; height: 112px; 
            background-size: 100% 100%; 
            box-sizing: border-box; 
            border-radius: 5px; 
            box-shadow: 2px 2px 6px rgba(0,0,0,0.4); 
            cursor: pointer; 
            transition: all 0.3s ease-in-out; 
            position: absolute; 
            background-color: #eee; 
        }
        .card:active { transform: scale(0.95); }
        
        .stack-three { border: 3px solid yellow !important; box-shadow: 0 0 15px yellow !important; animation: pulse-border 1s infinite alternate; z-index: 50; }
        @keyframes pulse-border { from { border-color: yellow; } to { border-color: orange; } }
        
        .selectable { 
            border: 4px solid red !important; 
            box-shadow: 0 0 30px red !important; 
            z-index: 9999 !important; 
            animation: pulse 0.5s infinite alternate; 
        }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }
        
        .bomb-candidate { border: 2px solid orange !important; box-shadow: 0 0 15px orange !important; }
        .dimmed { opacity: 0.5; pointer-events: none; filter: grayscale(0.5); }

        /* [ÎÇ†ÏïÑÍ∞ÄÎäî Ïπ¥Îìú] */
        .flying-card { position: absolute; z-index: 9999; width: 70px; height: 112px; background-size: 100% 100%; border-radius: 5px; border: 3px solid gold; box-shadow: 0 0 20px yellow; transition: all 0.5s cubic-bezier(0.25, 1, 0.5, 1); }

        /* --- [UI ÏöîÏÜå] --- */
        #frame-1 { justify-content: flex-start; position: relative; }
        .profile-area { display: flex; align-items: center; gap: 10px; color: white; font-weight: bold; font-size: 14px; background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 10px; margin-bottom: 5px; width: fit-content; position: relative; border: 1px solid #555; }
        .profile-img { width: 45px; height: 60px; border-radius: 4px; border: 2px solid white; object-fit: cover; background: #ddd; }
        .info-stack { display: flex; flex-direction: column; justify-content: center; }
        
        .money-text { color: #ffff00; font-size: 14px; margin-top: 2px; transition: color 0.3s; }
        .money-text.negative { color: #ff4444; text-shadow: 0 0 5px red; } 
        
        .score-text { color: #00ff00; font-size: 16px; margin-top: 2px; text-shadow: 1px 1px 0 #000; }
        .speech-bubble { position: absolute; left: 110%; top: 0; background: white; color: black; padding: 8px 12px; border-radius: 10px; font-size: 14px; font-weight: bold; white-space: nowrap; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); display: none; z-index: 1000; }
        .speech-bubble::after { content: ''; position: absolute; left: -6px; top: 15px; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-right: 6px solid white; }
        
        #reaction-container { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            z-index: 4000; width: 100%; text-align: center;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none; 
        }
        #reaction-container.active { pointer-events: auto; }

        #opp-reaction-pop { width: 30%; filter: drop-shadow(0 0 20px white); transition: width 0.3s; }
        .reaction-text { font-weight: 900; color: gold; text-shadow: 4px 4px 0 red, 0 0 30px white; margin-bottom: -10px; display: none; white-space: nowrap; z-index: 4001; }
        .blinking { animation: flash-text 0.5s infinite alternate; }
        @keyframes flash-text { from { opacity: 1; transform: scale(1); } to { opacity: 0.7; transform: scale(1.1); } }

        #end-game-buttons {
            display: none; 
            gap: 15px; margin-top: 20px;
            z-index: 4002; pointer-events: auto;
        }
        .end-btn {
            padding: 12px 24px; font-size: 18px; font-weight: bold;
            border-radius: 50px; border: 3px solid white; cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transition: transform 0.2s, filter 0.2s;
        }
        .end-btn:hover { transform: scale(1.1); filter: brightness(1.2); }
        .rematch-btn { background: linear-gradient(to bottom, #00ccff, #0055ff); color: white; }
        .change-btn { background: linear-gradient(to bottom, #ff5555, #cc0000); color: white; }

        #opp-hand { 
            width: 450px; height: 120px; 
            position: relative; 
            margin: 0 auto; 
        }
        .opp-card-slot { 
            width: 70px; height: 112px; 
            background: url('back.png'); background-size: 100% 100%; 
            border-radius: 5px; background-color: #333; 
            position: absolute; 
            top: 0;
            transition: transform 0.3s, opacity 0.3s;
            box-shadow: -2px 0 5px rgba(0,0,0,0.5); 
        }
        .opp-card-revealed {
            box-shadow: 0 0 20px yellow !important;
            transform: scale(1.1);
            z-index: 100 !important;
        }

        #frame-2 { position: relative; overflow: hidden; }
        .dummy-stack { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70px; height: 112px; z-index: 100; }
        .dummy-card { position: absolute; width: 70px; height: 112px; background: url('back.png'); background-size: 100% 100%; border-radius: 5px; border: 1px solid #333; background-color: #333; }
        .dummy-active .dummy-top { box-shadow: 0 0 20px yellow, 0 0 40px orange; animation: glow-active 0.8s infinite alternate; cursor: pointer; }
        .dummy-inactive { opacity: 0.7; cursor: not-allowed; }
        @keyframes glow-active { from { box-shadow: 0 0 10px yellow; transform: scale(1); } to { box-shadow: 0 0 30px red; transform: scale(1.05); } }
        #field-area { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
        #field-area .card { pointer-events: auto; }

        .overlay-popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 4px solid gold; border-radius: 20px; padding: 30px; text-align: center; z-index: 5000; display: none; box-shadow: 0 0 50px rgba(255, 215, 0, 0.5); min-width: 300px; }
        .overlay-popup h2 { color: white; margin: 0 0 20px 0; font-size: 32px; text-shadow: 2px 2px 0 black; }
        .choice-btn { background: linear-gradient(to bottom, #ffcc00, #ff9900); border: 2px solid white; border-radius: 10px; padding: 15px 30px; font-size: 24px; font-weight: bold; cursor: pointer; margin: 0 10px; transition: transform 0.1s; }
        .choice-btn:hover { transform: scale(1.1); filter: brightness(1.2); }
        .stop-btn { background: linear-gradient(to bottom, #ff3333, #cc0000); color: white; }
        .shake-btn { background: linear-gradient(to bottom, #00ccff, #0099ff); color: white; }

        #effect-text { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 80px; font-weight: bold; color: yellow; text-shadow: 4px 4px 0 red; opacity: 0; pointer-events: none; z-index: 3000; width: 100%; text-align: center; }
        @keyframes pop-text { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
        
        #temp-card { width: 70px; height: 112px; background-size: 100% 100%; border-radius: 5px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); z-index: 1500; box-shadow: 0 0 30px white; transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); background-color: #eee; }
        #guide-msg { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: #fff; padding: 8px 25px; border-radius: 50px; font-size: 20px; font-weight: bold; display: none; z-index: 2000; border: 2px solid yellow; white-space: nowrap; pointer-events: none; }

        #frame-3 { justify-content: flex-start; }
        .user-profile-text { text-align: right; color: white; font-weight: bold; font-size: 14px; background: rgba(0,0,0,0.5); padding: 6px 12px; border-radius: 8px; margin-top: 10px; align-self: flex-end; width: fit-content; border: 1px solid #555; }
        .user-money { color: yellow; font-size: 14px; margin-top: 2px; }
        #my-score-display { font-size: 16px; color: #ffcc00; display: block; }
        #my-hand { width: 450px; justify-content: flex-end; padding-right: 5px; display: flex; flex-wrap: wrap; gap: 8px; margin-top: auto; }
        .hand-card { position: relative; margin: 0; transition: transform 0.2s; }
        .hand-card:hover { transform: translateY(-20px) scale(1.05); z-index: 100; box-shadow: 0 0 10px yellow; }

        .captured-zone { display: flex; flex-direction: column; gap: 2px; min-height: 250px; padding-left: 10px; position: relative; }
        #frame-1 .captured-zone { margin-top: auto; }
        .captured-row { display: flex; flex-wrap: nowrap; align-items: center; height: 75px; overflow: visible; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .captured-row:last-child { border-bottom: none; }
        .pi-container { display: flex; flex-direction: column; position: relative; }
        .pi-row { display: flex; flex-wrap: nowrap; height: 75px; align-items: center; }
        .pi-row.second-line { margin-top: -50px; z-index: 5; padding-left: 30px; }
        .captured-card { width: 70px; height: 112px; background-size: 100% 100%; border-radius: 4px; border: 1px solid #aaa; box-shadow: 2px 0 5px rgba(0,0,0,0.3); margin-left: -35px; flex-shrink: 0; transition: transform 0.2s; position: relative; background-color: #eee; }
        .captured-card.start-group { margin-left: 0 !important; }
        .captured-card:hover { transform: translateY(-20px); z-index: 50; margin-right: 20px; }
        .row-label { font-size: 12px; color: rgba(255,255,255,0.5); width: 20px; margin-right: 5px; writing-mode: vertical-rl; }

        #result-board { width: 320px; height: 70px; background-color: rgba(0, 0, 0, 0.85); color: white; border-radius: 15px; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 18px; font-weight: bold; position: absolute; left: 50%; transform: translateX(-50%); bottom: -80px; z-index: 200; display: none; border: 2px solid gold; box-shadow: 0 0 15px black; }
        .gobak-text { color: #ff3333; font-size: 20px; animation: blink 0.5s infinite alternate; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.5; } }

        #timer-ui {
            position: absolute; top: 20px; right: 20px; width: 80px; height: 80px;
            background: rgba(0, 0, 0, 0.4); border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, 0.3);
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 40px; font-weight: bold;
            z-index: 5500; pointer-events: none;
            backdrop-filter: blur(5px);
            font-family: 'Courier New', Courier, monospace;
        }
        #timer-ui.warning { color: #ff3333; border-color: #ff3333; animation: pulse-timer 0.5s infinite alternate; }
        @keyframes pulse-timer { from { transform: scale(1); } to { transform: scale(1.1); } }

        #start-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); z-index: 6000; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; 
        }
        .char-select { display: flex; gap: 40px; margin-top: 30px; flex-wrap: wrap; justify-content: center; }
        .char-card { text-align: center; cursor: pointer; transition: 0.3s; }
        .char-card:hover { transform: scale(1.05); color: yellow; }
        .char-img { width: 95px; height: 148px; border-radius: 8px; box-shadow: 0 0 10px rgba(255,255,255,0.2); background: #333; }
        input { padding: 10px; font-size: 20px; text-align: center; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="timer-ui" style="display:none;">10</div>

    <div id="game-container">
        <audio id="snd-chak" src="chak.mp3"></audio>
        <audio id="snd-tak" src="tak.mp3"></audio>
        <audio id="snd-shuffle" src="shuffle.mp3"></audio>
        <audio id="snd-bomb" src="bomb.mp3"></audio>
        <audio id="snd-get" src="get.mp3"></audio>
        <audio id="snd-go" src="go.mp3"></audio>
        <audio id="snd-stop" src="stop.mp3"></audio>
        <audio id="snd-win" src="win.mp3"></audio>
        <audio id="snd-fail" src="fail.mp3"></audio>

        <div id="frame-1" class="frame wood-bg wood-bg-fallback">
            <div class="profile-area">
                <img id="opp-img" src="s_2.png" class="profile-img">
                <div class="info-stack">
                    <div id="opp-name">ÏÉÅÎåÄÎ∞©</div>
                    <div id="opp-money" class="money-text">100,000Ïõê</div>
                    <div id="opp-score-display" class="score-text">0Ï†ê</div>
                </div>
                <div id="opp-speech" class="speech-bubble"></div>
            </div>
            
            <div id="reaction-container">
                <div id="reaction-text" class="reaction-text">Good</div>
                <img id="opp-reaction-pop" src="">
                <div id="end-game-buttons">
                    <button class="end-btn rematch-btn" onclick="handleRematch()">Ìïú Ìåê Îçî!</button>
                    <button class="end-btn change-btn" onclick="returnToCharSelect()">ÏÉÅÎåÄ Î≥ÄÍ≤Ω</button>
                </div>
            </div>

            <div id="opp-hand"></div>
            <div class="captured-zone" id="opp-captured-zone"></div>
        </div>

        <div id="frame-2" class="frame green-bg">
            <div id="start-overlay">
                <h2>Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî</h2>
                <input type="text" id="player-name-input" value="ÏóòÏÇ¨">
                <h3>ÏÉÅÎåÄÎ∞© ÏÑ†ÌÉù</h3>
                <div class="char-select">
                    <div class="char-card" onclick="startGame('sangchu')"><img src="s_1.png" class="char-img"><p>ÏÉÅÏ∂î</p></div>
                    <div class="char-card" onclick="startGame('ggam')"><img src="s_2.png" class="char-img"><p>ÍπåÎØ∏</p></div>
                    <div class="char-card" onclick="startGame('kimchi')"><img src="s_3.png" class="char-img"><p>ÍπÄÏπò</p></div>
                </div>
            </div>

            <div id="effect-text"></div> 
            <div id="temp-card"></div>
            <div id="field-area"></div>
            <div id="guide-msg"></div>
            
            <div id="choice-overlay" class="overlay-popup">
                <h2>Ïñ¥Îñ§ Í±∏Î°ú Ìï†ÍπåÏöî?</h2>
                <button class="choice-btn" onclick="confirmBombAction(true)">üí£ Ìè≠ÌÉÑ!</button>
                <button class="choice-btn shake-btn" onclick="confirmBombAction(false)">üëã ÌùîÎì§Í∏∞Îßå</button>
            </div>

            <div id="go-stop-overlay" class="overlay-popup">
                <h2 id="go-stop-msg">5Ï†êÏù¥ ÎÇ¨ÏäµÎãàÎã§!</h2>
                <button class="choice-btn" onclick="userDecideGoStop(true)">GO (Í≥†)</button>
                <button class="choice-btn stop-btn" onclick="userDecideGoStop(false)">STOP (Ïä§ÌÜ±)</button>
            </div>

            <div id="dummy-stack" class="dummy-stack dummy-inactive" onclick="clickDummy()">
                <div class="dummy-card" style="top:0; left:0;"></div>
                <div class="dummy-card" style="top:-3px; left:-2px;"></div>
                <div class="dummy-card" style="top:-6px; left:2px;"></div>
                <div class="dummy-card dummy-top" style="top:-9px; left:0;"></div>
            </div>
        </div>

        <div id="frame-3" class="frame wood-bg wood-bg-fallback">
            <div class="captured-zone" id="my-captured-zone">
                <div id="result-board"></div>
            </div>
            <div id="my-hand"></div>
            <div class="user-profile-text">
                <div id="my-name-display">ÏóòÏÇ¨</div>
                <div id="my-money" class="user-money">100,000Ïõê</div>
                <div id="my-score-display" class="score-text">0Ï†ê</div>
            </div>
        </div>
    </div>
</div>

<script>
    const allCards = []; for(let m=1; m<=12; m++){ for(let i=1; i<=4; i++){ allCards.push(`${m}_${i}`); } }
    const FIELD_SLOTS = [{x: 60, y: 50}, {x: 190, y: 50}, {x: 320, y: 50}, {x: 60, y: 200}, {x: 320, y: 200}, {x: 60, y: 350}, {x: 320, y: 350}, {x: 60, y: 500}, {x: 190, y: 500}, {x: 320, y: 500}, {x: 60, y: 620}, {x: 320, y: 620}];
    const GWANG = ['1_1', '3_1', '8_1', '11_1', '12_1'];
    const SSANG_PI = ['9_1', '11_2', '12_4'];
    const ANIMALS = ['2_1', '4_1', '5_1', '8_2', '7_1', '6_1', '10_1', '12_2']; 
    const RIBBONS = ['1_2', '2_2', '3_2', '4_2', '5_2', '6_2', '7_2', '9_2', '10_2', '12_3'];

    let myTotalMoney = 100000;
    const characterStats = {
        'sangchu': { name: 'ÏÉÅÏ∂î', money: 100000, img: 's_1.png' },
        'ggam': { name: 'ÍπåÎØ∏', money: 100000, img: 's_2.png' },
        'kimchi': { name: 'ÍπÄÏπò', money: 100000, img: 's_3.png' }
    };

    let gameState = {
        deck: [], myHand: [], oppHand: [], field: [], myCaptured: [], oppCaptured: [],
        currentTurn: 'USER', turnPhase: 'HAND', 
        isSelecting: false, pendingSourceCard: null, selectableFieldCards: [],
        bombBonusTurns: 0, tempBombCard: null, tempBombMatch: null, lastDiscardedCard: null,
        shakeCount: 0, oppShakeCount: 0, myScore: 0, oppScore: 0,
        myGoCount: 0, oppGoCount: 0, myLastCheckScore: 0, oppLastCheckScore: 0,
        mySsaCount: 0, oppSsaCount: 0, 
        myTurnCount: 0, oppTurnCount: 0, 
        usedBombBonusThisTurn: false,
        currentOpponentId: 'ggam',
        reactionTimer: null,
        turnTimer: null, 
        timeLeft: 10,
        turnLog: { capturedMonth: null, capturedCount: 0, capturedCards: [] }
    };

    function resizeGame() {
        const wrapper = document.getElementById('game-wrapper');
        const container = document.getElementById('game-container');
        const targetWidth = 1500;
        const targetHeight = 720;
        const wrapperWidth = wrapper.clientWidth;
        const wrapperHeight = wrapper.clientHeight;
        const scale = Math.min(wrapperWidth / targetWidth, wrapperHeight / targetHeight);
        container.style.transform = `scale(${scale})`;
    }
    window.addEventListener('resize', resizeGame);
    window.addEventListener('load', resizeGame);

    function startTurnTimer() {
        const timerUI = document.getElementById('timer-ui');
        if (gameState.currentTurn !== 'USER') { timerUI.style.display = 'none'; return; }
        clearInterval(gameState.turnTimer);
        gameState.timeLeft = 15; 
        timerUI.innerText = gameState.timeLeft;
        timerUI.style.display = 'flex';
        timerUI.classList.remove('warning');
        gameState.turnTimer = setInterval(() => {
            gameState.timeLeft--;
            timerUI.innerText = gameState.timeLeft;
            if (gameState.timeLeft <= 5) timerUI.classList.add('warning');
            if (gameState.timeLeft <= 0) {
                clearInterval(gameState.turnTimer);
                showEffect("ÏãúÍ∞Ñ Ï¥àÍ≥º!");
                autoPlayCard();
            }
        }, 1000);
    }
    function stopTimer() { clearInterval(gameState.turnTimer); document.getElementById('timer-ui').style.display = 'none'; }
    
    function autoPlayCard() { 
        if (gameState.turnPhase === 'HAND') { 
            if (gameState.myHand.length > 0) playHandCard(gameState.myHand[0], false); 
        } else if (gameState.turnPhase === 'DUMMY') { 
            clickDummy(); 
        }
        if (gameState.bombBonusTurns > 0 && gameState.currentTurn === 'USER') { clickDummy(); }
    }

    function startGame(charId) {
        const inputName = document.getElementById('player-name-input').value;
        if(!inputName) { alert("Ïù¥Î¶ÑÏùÑ Ïç®Ï£ºÏÑ∏Ïöî!"); return; }
        
        document.getElementById('my-name-display').innerText = inputName;
        gameState.currentOpponentId = charId;
        
        const oppData = characterStats[charId];
        document.getElementById('opp-name').innerText = oppData.name;
        document.getElementById('opp-img').src = oppData.img;
        document.getElementById('opp-img').dataset.original = oppData.img;

        document.getElementById('reaction-container').style.transform = "translate(-50%, -50%) scale(0)";
        document.getElementById('reaction-container').classList.remove('active');
        document.getElementById('end-game-buttons').style.display = 'none';
        document.getElementById('result-board').style.display = 'none';
        document.getElementById('opp-speech').style.display = 'none'; 
        
        if(gameState.reactionTimer) { clearTimeout(gameState.reactionTimer); gameState.reactionTimer = null; }

        updateMoneyDisplay(); 
        document.getElementById('start-overlay').style.display = 'none';
        playSound('shuffle'); 
        dealCards();
        setTimeout(resizeGame, 100);
    }

    function updateMoneyDisplay() { 
        const myMoneyEl = document.getElementById('my-money');
        const oppMoneyEl = document.getElementById('opp-money');
        const oppMoney = characterStats[gameState.currentOpponentId].money;
        myMoneyEl.innerText = myTotalMoney.toLocaleString() + "Ïõê";
        oppMoneyEl.innerText = oppMoney.toLocaleString() + "Ïõê";
        if (myTotalMoney < 0) myMoneyEl.classList.add('negative'); else myMoneyEl.classList.remove('negative');
        if (oppMoney < 0) oppMoneyEl.classList.add('negative'); else oppMoneyEl.classList.remove('negative');
    }
    
    function dealCards() {
        gameState.myCaptured = []; gameState.oppCaptured = [];
        gameState.field = []; gameState.myHand = []; gameState.oppHand = [];
        gameState.mySsaCount = 0; gameState.oppSsaCount = 0; 
        gameState.myTurnCount = 0; gameState.oppTurnCount = 0; 
        gameState.bombBonusTurns = 0; gameState.usedBombBonusThisTurn = false;
        
        let deck = [...allCards].sort(() => Math.random() - 0.5);
        gameState.myHand = deck.slice(0, 10); gameState.oppHand = deck.slice(10, 20); gameState.deck = deck.slice(28); 
        const initialField = deck.slice(20, 28);
        
        const monthCounts = {};
        initialField.forEach(card => { const m = card.split('_')[0]; monthCounts[m] = (monthCounts[m] || 0) + 1; });

        let slotIdx = 0; const usedMonths = new Set();
        initialField.forEach(card => {
            const m = card.split('_')[0];
            if (monthCounts[m] === 3) {
                if (!usedMonths.has(m)) {
                    const trio = initialField.filter(c => c.split('_')[0] === m);
                    trio.forEach(c => gameState.field.push({ id: c, slotIndex: slotIdx }));
                    slotIdx++; usedMonths.add(m);
                }
            }
        });
        initialField.forEach(card => {
            const m = card.split('_')[0];
            if (monthCounts[m] !== 3) { gameState.field.push({ id: card, slotIndex: slotIdx }); slotIdx++; }
        });

        gameState.currentTurn = 'USER'; gameState.turnPhase = 'HAND'; 
        gameState.shakeCount = 0; gameState.oppShakeCount = 0; gameState.myScore = 0; gameState.oppScore = 0;
        gameState.myGoCount = 0; gameState.oppGoCount = 0; gameState.myLastCheckScore = 0; gameState.oppLastCheckScore = 0;
        
        document.getElementById('opp-speech').style.display = 'none';
        if(gameState.reactionTimer) { clearTimeout(gameState.reactionTimer); gameState.reactionTimer = null; }

        updateUI(); updateScoreDisplay(); renderField(); renderMyHand(); renderOppHandBack(); renderCaptured('my'); renderCaptured('opp'); 
        startTurnTimer(); 
    }

    function reactOpponent(type) {
        const bubble = document.getElementById('opp-speech');
        const container = document.getElementById('reaction-container');
        const popImg = document.getElementById('opp-reaction-pop');
        const rText = document.getElementById('reaction-text');
        const btnGroup = document.getElementById('end-game-buttons');
        const charId = gameState.currentOpponentId; 
        
        let finalImageName = "";
        if (charId === 'sangchu') {
            if (type === 'user_win') finalImageName = "sangchu_1.png"; 
            else if (type === 'user_lose') finalImageName = "sangchu_2.png"; 
            else finalImageName = "sangchu_1.png";
        } else {
            let prefix = (charId === 'ggam') ? "ggam" : "kimchi";
            if (type === 'user_win') finalImageName = prefix + "_1.png"; 
            else if (type === 'user_lose') finalImageName = prefix + "_2.png"; 
            else finalImageName = prefix + "_1.png";
        }
        
        if (gameState.reactionTimer) { clearTimeout(gameState.reactionTimer); gameState.reactionTimer = null; }

        let msg = ""; let autoHide = true; let isBigCeremony = false;
        rText.style.display = 'none'; rText.classList.remove('blinking');
        popImg.style.width = '30%'; btnGroup.style.display = 'none'; 
        container.classList.remove('active');

        if (type === 'jjok') { msg = "Ïñ¥Î®∏! Ï™ΩÏù¥Îã§!"; }
        else if (type === 'sweep') { msg = "Îã§ ÎÇ¥ Í±∞Ïïº!"; }
        else if (type === 'decision') { msg = "Í≥†? Ïä§ÌÜ±?"; }
        else if (type === 'gobak') { msg = "ÏïÑÏù¥Í≥† Í≥†Î∞ïÏù¥Ïïº!"; }
        else if (type === 'user_win') { msg = "Good!"; isBigCeremony = true; autoHide = false; rText.style.fontSize = "150px"; }
        else if (type === 'user_lose') { msg = "Îã§Ïãú Ìï†Îûò?"; isBigCeremony = true; autoHide = false; rText.style.fontSize = "80px"; }
        else if (type === 'nagari') { msg = "ÎÇòÍ∞ÄÎ¶¨"; isBigCeremony = true; autoHide = false; rText.style.fontSize = "100px"; popImg.style.display = 'none'; }

        if(type !== 'nagari') { popImg.style.display = 'block'; popImg.src = finalImageName; }

        if (isBigCeremony) {
            bubble.style.display = 'none'; 
            popImg.style.width = '200px'; rText.innerText = msg; rText.style.display = 'block'; rText.classList.add('blinking'); btnGroup.style.display = 'flex'; container.classList.add('active'); container.style.transform = "translate(-50%, -50%) scale(1)"; 
        } else {
            bubble.innerText = msg; bubble.style.display = 'block'; container.style.transform = "translate(-50%, -50%) scale(1)";
        }

        if (autoHide) {
            gameState.reactionTimer = setTimeout(() => { bubble.style.display = 'none'; container.style.transform = "translate(-50%, -50%) scale(0)"; }, 2000);
        }
    }

    function handleRematch() {
        document.getElementById('reaction-container').style.transform = "translate(-50%, -50%) scale(0)";
        document.getElementById('end-game-buttons').style.display = 'none';
        document.getElementById('result-board').style.display = 'none';
        playSound('shuffle'); dealCards();
    }

    function returnToCharSelect() {
        document.getElementById('reaction-container').style.transform = "translate(-50%, -50%) scale(0)";
        document.getElementById('end-game-buttons').style.display = 'none';
        document.getElementById('result-board').style.display = 'none';
        document.getElementById('opp-speech').style.display = 'none'; 
        if(gameState.reactionTimer) { clearTimeout(gameState.reactionTimer); gameState.reactionTimer = null; }
        document.getElementById('start-overlay').style.display = 'flex';
    }

    function getEmptySlot() { const occupied = gameState.field.map(obj => obj.slotIndex); for(let i=0; i<FIELD_SLOTS.length; i++) { if(!occupied.includes(i)) return i; } return -1; }
    
    function updateUI() {
        const dummyEl = document.getElementById('dummy-stack'); const guideEl = document.getElementById('guide-msg');
        if (gameState.currentTurn !== 'USER') { 
            dummyEl.classList.remove('dummy-active'); dummyEl.classList.add('dummy-inactive'); 
            guideEl.style.display = 'none'; renderMyHand(); return; 
        }
        if (gameState.bombBonusTurns > 0) { 
            gameState.turnPhase = 'BOMB_BONUS'; 
            dummyEl.classList.add('dummy-active'); dummyEl.classList.remove('dummy-inactive');
            guideEl.innerText = `Ìè≠ÌÉÑ Î≥¥ÎÑàÏä§ Í∏∞Ìöå! (${gameState.bombBonusTurns}Ìöå) Ìå®Î•º ÎÇ¥Í±∞ÎÇò ÎçîÎØ∏Î•º Î∞îÎ°ú ÎàÑÎ•¥ÏÑ∏Ïöî.`;
            guideEl.style.display = 'block'; 
            renderMyHand(); return; 
        }
        guideEl.style.display = 'none';
        if (gameState.turnPhase === 'HAND') { dummyEl.classList.remove('dummy-active'); dummyEl.classList.add('dummy-inactive'); } 
        else if (gameState.turnPhase === 'DUMMY') { dummyEl.classList.add('dummy-active'); dummyEl.classList.remove('dummy-inactive'); }
        renderMyHand();
    }

    function updateScoreDisplay() {
        gameState.myScore = calculateScore('USER'); gameState.oppScore = calculateScore('OPP');
        document.getElementById('my-score-display').innerText = `${gameState.myScore}Ï†ê (Go: ${gameState.myGoCount})`;
        document.getElementById('opp-score-display').innerText = `${gameState.oppScore}Ï†ê (Go: ${gameState.oppGoCount})`;
    }
    function calculateScore(who) {
        let score = 0; let gwangCnt = 0; let rainGwang = false; let animalCnt = 0; let godoriCnt = 0; let ribbonCnt = 0; let hongdan = 0, cheongdan = 0, chodan = 0; let piCnt = 0;
        const targetList = who === 'USER' ? gameState.myCaptured : gameState.oppCaptured;
        const targetShake = who === 'USER' ? gameState.shakeCount : gameState.oppShakeCount;
        
        targetList.forEach(id => {
            if (GWANG.includes(id)) { gwangCnt++; if (id === '12_1') rainGwang = true; }
            else if (ANIMALS.includes(id)) { animalCnt++; if (['2_1', '4_1', '8_2'].includes(id)) godoriCnt++; }
            else if (RIBBONS.includes(id)) { 
                ribbonCnt++; 
                if (['1_2', '2_2', '3_2'].includes(id)) hongdan++; 
                if (['6_2', '9_2', '10_2'].includes(id)) cheongdan++; 
                if (['4_2', '5_2', '7_2'].includes(id)) chodan++; 
            } else { if (SSANG_PI.includes(id)) piCnt += 2; else piCnt += 1; }
        });

        if (gwangCnt === 5) score += 15; else if (gwangCnt === 4) score += 4; else if (gwangCnt === 3) score += (rainGwang ? 2 : 3);
        if (animalCnt >= 5) score += (animalCnt - 4); if (godoriCnt === 3) score += 5;
        if (ribbonCnt >= 5) score += (ribbonCnt - 4); 
        if (hongdan === 3) score += 3; if (cheongdan === 3) score += 3; if (chodan === 3) score += 3; 
        if (piCnt >= 10) score += (piCnt - 9);
        
        if (targetShake > 0) { score *= Math.pow(2, targetShake); }
        return score;
    }

    function renderField() { 
        const container = document.getElementById('field-area'); container.innerHTML = ""; 
        const monthCounts = {}; const slotCounts = {}; 
        gameState.field.forEach(obj => { const m = obj.id.split('_')[0]; monthCounts[m] = (monthCounts[m] || 0) + 1; }); 

        gameState.field.forEach(cardObj => { 
            const el = document.createElement('div'); el.className = 'card'; 
            el.style.backgroundImage = `url('${cardObj.id}.png')`; 
            const pos = FIELD_SLOTS[cardObj.slotIndex] || {x:200,y:300}; 
            const currentCount = slotCounts[cardObj.slotIndex] || 0;
            const offsetX = currentCount * 15; const offsetY = currentCount * 15; 
            
            el.style.left = (pos.x + offsetX) + 'px'; el.style.top = (pos.y + offsetY) + 'px'; el.style.zIndex = currentCount; 
            slotCounts[cardObj.slotIndex] = currentCount + 1;
            const m = cardObj.id.split('_')[0]; 
            if (monthCounts[m] === 3) { el.classList.add('stack-three'); } 
            
            if (gameState.isSelecting && gameState.currentTurn === 'USER') { 
                if (gameState.selectableFieldCards.includes(cardObj.id)) { el.classList.add('selectable'); el.onclick = () => confirmSelection(cardObj); } 
                else { el.classList.add('dimmed'); } 
            } 
            container.appendChild(el); 
        }); 
    }

    function renderMyHand() { 
        const container = document.getElementById('my-hand'); container.innerHTML = ""; 
        const monthCounts = {}; gameState.myHand.forEach(id => { const m = id.split('_')[0]; monthCounts[m] = (monthCounts[m] || 0) + 1; }); 
        gameState.myHand.forEach(card => { 
            const el = document.createElement('div'); el.className = 'card hand-card'; el.style.backgroundImage = `url('${card}.png')`; 
            const month = card.split('_')[0]; const isTrio = monthCounts[month] === 3; 
            if (isTrio) { el.classList.add('bomb-candidate'); } 
            if (gameState.currentTurn !== 'USER' || (gameState.turnPhase !== 'HAND' && gameState.turnPhase !== 'BOMB_BONUS') || gameState.isSelecting) { 
                el.classList.add('dimmed'); 
            } else { el.onclick = () => playHandCard(card, isTrio); } 
            container.appendChild(el); 
        }); 
    }
    
    function renderOppHandBack() { 
        const container = document.getElementById('opp-hand'); container.innerHTML = ""; 
        const overlapStep = 35; const totalWidth = (gameState.oppHand.length - 1) * overlapStep + 70; const startX = (450 - totalWidth) / 2;
        for(let i=0; i<gameState.oppHand.length; i++) { const el = document.createElement('div'); el.className = 'opp-card-slot'; el.id = `opp-card-${i}`; el.style.left = (startX + i * overlapStep) + 'px'; el.style.zIndex = i; container.appendChild(el); } 
    }
    function renderCaptured(who) { const list = who === 'my' ? gameState.myCaptured : gameState.oppCaptured; const containerId = who === 'my' ? 'my-captured-zone' : 'opp-captured-zone'; const container = document.getElementById(containerId); let scoreBoard = document.getElementById('result-board'); if(who === 'my') {} container.innerHTML = ""; let gwangList = [], animalList = [], ribbonList = [], piList = []; list.forEach(id => { if(GWANG.includes(id)) gwangList.push(id); else if(SSANG_PI.includes(id)) piList.push(id); else if(ANIMALS.includes(id)) animalList.push(id); else if(RIBBONS.includes(id)) ribbonList.push(id); else piList.push(id); }); piList.sort((a,b) => { const isA = SSANG_PI.includes(a); const isB = SSANG_PI.includes(b); if(isA && !isB) return 1; if(!isA && isB) return -1; return 0; }); container.appendChild(createSimpleRow(gwangList, 'Í¥ë')); container.appendChild(createSimpleRow(animalList, 'ÎèôÎ¨º')); container.appendChild(createSimpleRow(ribbonList, 'Îù†')); const piContainer = document.createElement('div'); piContainer.className = 'pi-container'; const row1Cards = piList.slice(0, 10); const row2Cards = piList.slice(10); const row1 = createSimpleRow(row1Cards, 'Ìîº', false); row1.className = 'pi-row'; piContainer.appendChild(row1); if (row2Cards.length > 0) { const row2 = createSimpleRow(row2Cards, '', true); row2.className = 'pi-row second-line'; piContainer.appendChild(row2); } container.appendChild(piContainer); if (who === 'my' && scoreBoard) container.appendChild(scoreBoard); updateScoreDisplay(); }
    function createSimpleRow(cards, label, isSecondLine) { const row = document.createElement('div'); row.className = 'captured-row'; if (!isSecondLine) { const labelEl = document.createElement('div'); labelEl.className = 'row-label'; labelEl.innerText = label; row.appendChild(labelEl); } else { const labelEl = document.createElement('div'); labelEl.className = 'row-label'; row.appendChild(labelEl); } cards.forEach((id, idx) => { const c = document.createElement('div'); c.className = 'captured-card'; if(idx === 0) c.classList.add('start-group'); c.style.backgroundImage = `url('${id}.png')`; row.appendChild(c); }); return row; }

    function playHandCard(cardId, isTrio) { 
        if(gameState.currentTurn !== 'USER') return;
        if (gameState.turnPhase === 'HAND') { gameState.myTurnCount++; }
        stopTimer(); 
        const playedMonth = cardId.split('_')[0]; const matchingCards = gameState.field.filter(obj => obj.id.split('_')[0] === playedMonth); if (isTrio) { if (matchingCards.length === 1) { gameState.tempBombCard = cardId; gameState.tempBombMatch = matchingCards[0]; document.getElementById('choice-overlay').style.display = 'block'; return; } else if (matchingCards.length === 0) { performShake(cardId); executeNormalPlay(cardId); return; } } executeNormalPlay(cardId); 
    }
    function confirmBombAction(doBomb) { document.getElementById('choice-overlay').style.display = 'none'; if (doBomb) { performBomb(gameState.tempBombCard.split('_')[0], gameState.tempBombMatch, 'USER'); } else { performShake(gameState.tempBombCard); executeNormalPlay(gameState.tempBombCard); } gameState.tempBombCard = null; gameState.tempBombMatch = null; }
    function performShake(cardId) { showEffect("ÌùîÎì§Í∏∞!"); playSound('chak'); gameState.shakeCount++; }
    
    function executeNormalPlay(cardId) { 
        gameState.turnLog = { capturedMonth: null, capturedCount: 0, capturedCards: [] };
        const idx = gameState.myHand.indexOf(cardId); 
        if(idx > -1) gameState.myHand.splice(idx, 1); 
        const playedMonth = cardId.split('_')[0]; 
        const match = gameState.field.find(obj => obj.id.split('_')[0] === playedMonth); 
        
        if (!match) { gameState.lastDiscardedCard = cardId; } else { gameState.lastDiscardedCard = null; } 
        const result = attemptPlay(cardId, 'HAND', 'USER'); 
        if (result === 'SELECT_MODE') return; 
        
        gameState.turnPhase = 'DUMMY'; updateUI(); startTurnTimer(); 
    }

    function performBomb(month, fieldObj, who) { showEffect("Ìè≠ÌÉÑ!"); playSound('bomb'); if(who === 'USER') { gameState.shakeCount++; const bombCards = gameState.myHand.filter(c => c.split('_')[0] === month); bombCards.forEach(c => { const i = gameState.myHand.indexOf(c); if(i > -1) gameState.myHand.splice(i, 1); gameState.myCaptured.push(c); }); const fIdx = gameState.field.findIndex(obj => obj.id === fieldObj.id); if(fIdx > -1) gameState.field.splice(fIdx, 1); gameState.myCaptured.push(fieldObj.id); stealOpponentPi('USER'); renderCaptured('my'); renderField(); renderMyHand(); gameState.bombBonusTurns = 2; gameState.lastDiscardedCard = null; gameState.turnPhase = 'BOMB_BONUS'; updateUI(); endTurn(); } else { gameState.oppShakeCount++; const bombCards = gameState.oppHand.filter(c => c.split('_')[0] === month); bombCards.forEach(c => { const i = gameState.oppHand.indexOf(c); if(i > -1) gameState.oppHand.splice(i, 1); gameState.oppCaptured.push(c); }); const fIdx = gameState.field.findIndex(obj => obj.id === fieldObj.id); if(fIdx > -1) gameState.field.splice(fIdx, 1); gameState.oppCaptured.push(fieldObj.id); stealOpponentPi('OPP'); renderCaptured('opp'); renderField(); renderOppHandBack(); setTimeout(endTurn, 1000); } }
    
    function clickDummy() { 
        if(gameState.currentTurn !== 'USER') return; 
        stopTimer();
        if (gameState.bombBonusTurns > 0 && gameState.turnPhase === 'BOMB_BONUS') { gameState.usedBombBonusThisTurn = true; } 
        else if (gameState.turnPhase !== 'DUMMY') { return; }

        if(gameState.deck.length === 0) { checkGameEnd(true); return; } 
        
        const drawnCard = gameState.deck.pop(); 
        const tempEl = document.getElementById('temp-card'); tempEl.style.backgroundImage = `url('${drawnCard}.png')`; tempEl.style.transform = "translate(-50%, -50%) scale(1.5)"; tempEl.style.display = "block"; 
        
        setTimeout(() => { 
            tempEl.style.display = "none"; tempEl.style.transform = "translate(-50%, -50%) scale(0)"; 
            const drawnMonth = drawnCard.split('_')[0];
            if (gameState.turnLog.capturedCount === 2 && gameState.turnLog.capturedMonth === drawnMonth) { handleSsa(drawnCard, 'USER'); } 
            else { const result = attemptPlay(drawnCard, 'DUMMY', 'USER'); if (result === 'SELECT_MODE') return; }
            if(checkGoStopCondition('USER')) return; 
            endTurn(); 
        }, 1000); 
    }
    
    // [ÏàòÏ†ï: Ï≤´ ÌÑ¥Ïùº ÎïåÎßå 1000Ïõê Î≥¥ÎÑàÏä§ / Ìîº Î∫èÍ∏∞Îäî Îªë Î®πÏùÑ ÎïåÎßå]
    function handleSsa(dummyCard, who) {
        let ssaCount = 0; let isFirstTurn = false;
        if(who === 'USER') { 
            gameState.mySsaCount++; ssaCount = gameState.mySsaCount; 
            if (gameState.myTurnCount === 1) isFirstTurn = true;
        } else { 
            gameState.oppSsaCount++; ssaCount = gameState.oppSsaCount; 
            if (gameState.oppTurnCount === 1) isFirstTurn = true;
        }

        showEffect(`${ssaCount}Îªë!`); playSound('fail');

        // Ï≤´ Îªë(1ÌöåÏ∞®)Ïù¥Î©¥ÏÑú + Ï≤´ ÌÑ¥Ïùº ÎïåÎßå Îèà Î∫èÍ∏∞ (ÌîºÎäî Ïïà Î∫èÏùå)
        if (ssaCount === 1 && isFirstTurn) {
            const bonus = 1000;
            if (who === 'USER') {
                characterStats[gameState.currentOpponentId].money -= bonus; myTotalMoney += bonus;
                showEffect("Ï≤´ Îªë! 1,000Ïõê ÌöçÎìù!");
            } else {
                myTotalMoney -= bonus; characterStats[gameState.currentOpponentId].money += bonus;
                showEffect("Ï≤´ Îªë! 1,000Ïõê Î∫èÍπÄ!");
            }
            updateMoneyDisplay();
        }

        if (ssaCount >= 3) {
            setTimeout(() => {
                showEffect("Ïì∞Î¶¨Îªë! 5Ï†ê ÏäπÎ¶¨!");
                if (who === 'USER') { gameState.myScore = 5; finishGame('USER'); }
                else { gameState.oppScore = 5; finishGame('OPP'); }
            }, 1000);
            return; 
        }

        // Ìîº Î∫èÏßÄ ÏïäÍ≥† Í∑∏ÎÉ• ÌïÑÎìúÏóê ÏåìÍ∏∞
        const targetList = who === 'USER' ? gameState.myCaptured : gameState.oppCaptured;
        const cardsToReturn = gameState.turnLog.capturedCards; 
        cardsToReturn.forEach(c => { const idx = targetList.indexOf(c); if (idx > -1) targetList.splice(idx, 1); });
        const emptyIdx = getEmptySlot();
        const slot = emptyIdx !== -1 ? emptyIdx : 11;
        gameState.field.push({ id: cardsToReturn[0], slotIndex: slot });
        gameState.field.push({ id: cardsToReturn[1], slotIndex: slot });
        gameState.field.push({ id: dummyCard, slotIndex: slot });
        // stealOpponentPi(who); // ÏÇ≠Ï†ú: Îªë ÎÇ¨ÏùÑ Îïå Ìîº Ïïà Î∫èÏùå
        renderCaptured('my'); renderCaptured('opp'); renderField();
    }

    function handleSweep(who) {
        showEffect("ÏãπÏì∏Ïù¥!");
        if(who === 'USER') stealOpponentPi('USER'); else stealOpponentPi('OPP');
    }

    function playOpponentTurn() { 
        stopTimer(); 
        if (gameState.oppHand.length === 0 && gameState.deck.length === 0) { checkGameEnd(true); return; } 
        if (gameState.oppHand.length === 0) { oppDummyPlay(); return; } 
        gameState.oppTurnCount++;
        gameState.turnLog = { capturedMonth: null, capturedCount: 0, capturedCards: [] };
        let selectedCard = gameState.oppHand[0]; 
        for(let c of gameState.oppHand) { const m = c.split('_')[0]; const match = gameState.field.find(f => f.id.split('_')[0] === m); if(match) { selectedCard = c; break; } } 
        const cardIndex = gameState.oppHand.indexOf(selectedCard);
        const handCardEl = document.getElementById(`opp-card-${cardIndex}`);
        if(handCardEl) { handCardEl.style.backgroundImage = `url('${selectedCard}.png')`; handCardEl.classList.add('opp-card-revealed'); }
        
        setTimeout(() => {
            if(cardIndex > -1) gameState.oppHand.splice(cardIndex, 1);
            if(handCardEl) {
                const rect = handCardEl.getBoundingClientRect(); 
                const containerRect = document.getElementById('game-container').getBoundingClientRect(); 
                const style = window.getComputedStyle(document.getElementById('game-container'));
                const matrix = new WebKitCSSMatrix(style.transform);
                const scale = matrix.a; 
                const relX = (rect.left - containerRect.left) / scale; const relY = (rect.top - containerRect.top) / scale;
                handCardEl.style.opacity = '0'; 
                const flyer = document.createElement('div'); flyer.className = 'flying-card'; flyer.style.backgroundImage = `url('${selectedCard}.png')`; flyer.style.left = relX + 'px'; flyer.style.top = relY + 'px';
                document.getElementById('game-container').appendChild(flyer);
                const playedMonth = selectedCard.split('_')[0]; 
                const match = gameState.field.find(obj => obj.id.split('_')[0] === playedMonth); 
                let targetX, targetY;
                if (match) { const slotPos = FIELD_SLOTS[match.slotIndex]; targetX = slotPos.x; targetY = slotPos.y; } 
                else { const emptyIdx = getEmptySlot(); const safeIdx = emptyIdx !== -1 ? emptyIdx : 11; const slotPos = FIELD_SLOTS[safeIdx]; targetX = slotPos.x; targetY = slotPos.y; }
                setTimeout(() => { flyer.style.left = targetX + 'px'; flyer.style.top = targetY + 'px'; }, 50);
                setTimeout(() => { 
                    flyer.remove(); renderOppHandBack(); 
                    if (!match) { gameState.lastDiscardedCard = selectedCard; } else { gameState.lastDiscardedCard = null; } 
                    attemptPlay(selectedCard, 'HAND', 'OPP'); 
                    setTimeout(oppDummyPlay, 1000); 
                }, 550); 
            } else { renderOppHandBack(); attemptPlay(selectedCard, 'HAND', 'OPP'); setTimeout(oppDummyPlay, 1000); }
        }, 2000); 
    }

    function oppDummyPlay() { 
        if(gameState.deck.length === 0) { endTurn(); return; } 
        const drawnCard = gameState.deck.pop(); 
        const tempEl = document.getElementById('temp-card'); tempEl.style.backgroundImage = `url('${drawnCard}.png')`; tempEl.style.transform = "translate(-50%, -50%) scale(1.5)"; tempEl.style.display = "block"; 
        setTimeout(() => { 
            tempEl.style.display = "none"; tempEl.style.transform = "translate(-50%, -50%) scale(0)"; 
            const drawnMonth = drawnCard.split('_')[0];
            if (gameState.turnLog.capturedCount === 2 && gameState.turnLog.capturedMonth === drawnMonth) { handleSsa(drawnCard, 'OPP'); } 
            else { attemptPlay(drawnCard, 'DUMMY', 'OPP'); }
            if(checkGoStopCondition('OPP')) return; 
            endTurn(); 
        }, 1000); 
    }

    function attemptPlay(cardId, source, who, preCalculatedMatch) { 
        const playedMonth = cardId.split('_')[0]; 
        const matchingCards = preCalculatedMatch || gameState.field.filter(obj => obj.id.split('_')[0] === playedMonth); 
        
        if (who === 'OPP' && matchingCards.length === 2) { 
            captureCard(cardId, matchingCards[0], who); 
            if (source === 'DUMMY' && gameState.field.length === 0) handleSweep(who);
        } 
        else if (who === 'USER' && matchingCards.length === 2) { startSelectionMode(cardId, matchingCards); return 'SELECT_MODE'; } 
        else if (matchingCards.length === 1) { 
            if (source === 'DUMMY' && matchingCards[0].id === gameState.lastDiscardedCard) { 
                if(who === 'USER') { showEffect("Ï™Ω!"); stealOpponentPi('USER'); reactOpponent('jjok'); } 
                else { showEffect("Ï™Ω!"); stealOpponentPi('OPP'); reactOpponent('jjok'); } 
            } 
            captureCard(cardId, matchingCards[0], who); 
            if (source === 'HAND') { gameState.turnLog.capturedMonth = playedMonth; gameState.turnLog.capturedCount = 2; gameState.turnLog.capturedCards = [cardId, matchingCards[0].id]; }
            if (source === 'DUMMY' && gameState.field.length === 0) handleSweep(who);
        } else if (matchingCards.length >= 3) { 
            // [NEW] 3Ïû• ÏåìÏù∏ Ìå®(ÎªëÎÇú Ìå®)Î•º Î®πÏùÑ Îïå Ìîº Î∫èÍ∏∞
            captureAllStack(cardId, matchingCards, who); 
            showEffect("Îªë Î®πÏùå!");
            if(who === 'USER') stealOpponentPi('USER'); else stealOpponentPi('OPP');

            if (source === 'DUMMY' && gameState.field.length === 0) handleSweep(who);
        } else { discardCard(cardId); } 
        return 'DONE'; 
    }

    function startSelectionMode(sourceCard, matches) { gameState.isSelecting = true; gameState.pendingSourceCard = sourceCard; gameState.selectableFieldCards = matches.map(obj => obj.id); renderField(); renderMyHand(); stopTimer(); }
    function confirmSelection(selectedFieldObj) { 
        captureCard(gameState.pendingSourceCard, selectedFieldObj, 'USER'); 
        const playedMonth = gameState.pendingSourceCard.split('_')[0];
        gameState.turnLog.capturedMonth = playedMonth; gameState.turnLog.capturedCount = 2; gameState.turnLog.capturedCards = [gameState.pendingSourceCard, selectedFieldObj.id];
        gameState.isSelecting = false; gameState.pendingSourceCard = null; gameState.selectableFieldCards = []; renderField(); 
        if (gameState.turnPhase === 'HAND') { gameState.turnPhase = 'DUMMY'; updateUI(); startTurnTimer(); } else { if(checkGoStopCondition('USER')) return; endTurn(); } 
    }
    function captureCard(sourceCard, fieldObj, who) { const fIdx = gameState.field.findIndex(obj => obj.id === fieldObj.id); if(fIdx > -1) gameState.field.splice(fIdx, 1); playSound('chak'); if(who === 'USER') { gameState.myCaptured.push(sourceCard); gameState.myCaptured.push(fieldObj.id); } else { gameState.oppCaptured.push(sourceCard); gameState.oppCaptured.push(fieldObj.id); } renderCaptured('my'); renderCaptured('opp'); renderField(); if(who === 'USER') renderMyHand(); }
    function captureAllStack(sourceCard, fieldObjs, who) { fieldObjs.forEach(obj => { const fIdx = gameState.field.findIndex(f => f.id === obj.id); if(fIdx > -1) gameState.field.splice(fIdx, 1); if(who === 'USER') gameState.myCaptured.push(obj.id); else gameState.oppCaptured.push(obj.id); }); if(who === 'USER') gameState.myCaptured.push(sourceCard); else gameState.oppCaptured.push(sourceCard); playSound('chak'); renderCaptured('my'); renderCaptured('opp'); renderField(); if(who === 'USER') renderMyHand(); }
    function discardCard(cardId) { playSound('tak'); const emptyIdx = getEmptySlot(); if(emptyIdx !== -1) { gameState.field.push({ id: cardId, slotIndex: emptyIdx }); } else { gameState.field.push({ id: cardId, slotIndex: 11 }); } renderField(); }
    
    function stealOpponentPi(winnerWho) {
        let targetList = winnerWho === 'USER' ? gameState.oppCaptured : gameState.myCaptured;
        let destList = winnerWho === 'USER' ? gameState.myCaptured : gameState.oppCaptured;
        let candidates = targetList.filter(id => !GWANG.includes(id) && !ANIMALS.includes(id) && !RIBBONS.includes(id));
        if (candidates.length === 0) { if(winnerWho === 'USER') showEffect("ÏÉÅÎåÄ Ìîº ÏóÜÏùå!"); return; }
        let normalPis = candidates.filter(id => !SSANG_PI.includes(id));
        let doublePis = candidates.filter(id => SSANG_PI.includes(id));
        let stolenCard = null;
        if (normalPis.length > 0) stolenCard = normalPis[0]; else if (doublePis.length > 0) stolenCard = doublePis[0]; 
        if (stolenCard) {
            let stealIndex = targetList.indexOf(stolenCard);
            if (stealIndex > -1) {
                targetList.splice(stealIndex, 1); destList.push(stolenCard);
                const startZoneId = winnerWho === 'USER' ? 'opp-captured-zone' : 'my-captured-zone';
                const endZoneId = winnerWho === 'USER' ? 'my-captured-zone' : 'opp-captured-zone';
                const startRect = document.getElementById(startZoneId).getBoundingClientRect();
                const endRect = document.getElementById(endZoneId).getBoundingClientRect();
                const flyer = document.createElement('div'); flyer.className = 'flying-card'; flyer.style.backgroundImage = `url('${stolenCard}.png')`; flyer.style.left = (startRect.left + 50) + 'px'; flyer.style.top = (startRect.top + 50) + 'px'; document.body.appendChild(flyer);
                playSound('get'); 
                setTimeout(() => { flyer.style.left = (endRect.left + 50) + 'px'; flyer.style.top = (endRect.top + 50) + 'px'; }, 50);
                setTimeout(() => { flyer.remove(); renderCaptured('my'); renderCaptured('opp'); showEffect(winnerWho === 'USER' ? "Ìîº Î∫èÏñ¥Ïò¥!" : "Ìîº Î∫èÍπÄ!"); }, 850);
                renderCaptured('my'); renderCaptured('opp');
            }
        }
    }

    function endTurn() { 
        stopTimer(); 
        if (gameState.myHand.length === 0 && gameState.oppHand.length === 0) { 
            let winner = 'NAGARI';
            if (gameState.myGoCount > 0) winner = 'USER'; 
            else if (gameState.oppGoCount > 0) winner = 'OPP';
            else {
                 if (gameState.myScore >= 5 && gameState.myScore > gameState.oppScore) winner = 'USER';
                 else if (gameState.oppScore >= 5 && gameState.oppScore > gameState.myScore) winner = 'OPP';
            }
            finishGame(winner);
            return; 
        } 

        if (gameState.currentTurn === 'USER') { 
            if (gameState.usedBombBonusThisTurn) { gameState.bombBonusTurns--; gameState.usedBombBonusThisTurn = false; }
            gameState.currentTurn = 'OPP'; updateUI(); setTimeout(playOpponentTurn, 1000); 
        } else { 
            gameState.currentTurn = 'USER'; gameState.turnPhase = 'HAND'; updateUI(); startTurnTimer(); 
        } 
    }
    
    function checkGoStopCondition(who) { 
        updateScoreDisplay(); 
        const currentScore = who === 'USER' ? gameState.myScore : gameState.oppScore; 
        const lastScore = who === 'USER' ? gameState.myLastCheckScore : gameState.oppLastCheckScore; 
        if (currentScore >= 5 && currentScore > lastScore) { 
            const hand = who === 'USER' ? gameState.myHand : gameState.oppHand;
            if (hand.length === 0) { if (who === 'USER') userDecideGoStop(false); else aiDecideGoStop(currentScore); return true; }
            if (who === 'USER') { 
                const goCnt = gameState.myGoCount; document.getElementById('go-stop-msg').innerText = `${currentScore}Ï†êÏù¥ ÎÇ¨ÏäµÎãàÎã§! (${goCnt+1}Í≥†?)`; document.getElementById('go-stop-overlay').style.display = 'block'; stopTimer(); return true; 
            } else { aiDecideGoStop(currentScore); return true; } 
        } return false; 
    }

    function userDecideGoStop(isGo) { 
        document.getElementById('go-stop-overlay').style.display = 'none'; 
        if (isGo) { gameState.myGoCount++; gameState.myLastCheckScore = gameState.myScore; showEffect(gameState.myGoCount + " GO!"); playSound('go'); if (gameState.myHand.length === 0) { finishGame('USER'); return; } endTurn(); } 
        else { showEffect("STOP!"); playSound('stop'); finishGame('USER'); } 
    }

    function aiDecideGoStop(score) { 
        reactOpponent('decision'); 
        setTimeout(() => { 
            let isGo = true; if (score >= 7) isGo = false; 
            if (isGo) { gameState.oppGoCount++; gameState.oppLastCheckScore = gameState.oppScore; showEffect(gameState.oppGoCount + " GO! (ÏÉÅÎåÄ)"); playSound('go'); if (gameState.oppHand.length === 0) { finishGame('OPP'); return; } endTurn(); } 
            else { showEffect("STOP! (ÏÉÅÎåÄ)"); playSound('stop'); finishGame('OPP'); } 
        }, 1500); 
    }

    function finishGame(result) {
        stopTimer(); 
        const board = document.getElementById('result-board'); let text = ""; let finalScore = 0; let money = 0;
        let isMungTa = false; let isGwangBak = false; 

        if (result === 'USER') {
            let animalCnt = 0; gameState.myCaptured.forEach(id => { if (ANIMALS.includes(id)) animalCnt++; }); if (animalCnt >= 7) isMungTa = true;
            let myGwangCnt = 0; gameState.myCaptured.forEach(id => { if(GWANG.includes(id)) myGwangCnt++; });
            let oppGwangCnt = 0; gameState.oppCaptured.forEach(id => { if(GWANG.includes(id)) oppGwangCnt++; });
            if (myGwangCnt >= 3 && oppGwangCnt === 0) isGwangBak = true;
        } else if (result === 'OPP') {
            let animalCnt = 0; gameState.oppCaptured.forEach(id => { if (ANIMALS.includes(id)) animalCnt++; }); if (animalCnt >= 7) isMungTa = true;
            let oppGwangCnt = 0; gameState.oppCaptured.forEach(id => { if(GWANG.includes(id)) oppGwangCnt++; });
            let myGwangCnt = 0; gameState.myCaptured.forEach(id => { if(GWANG.includes(id)) myGwangCnt++; });
            if (oppGwangCnt >= 3 && myGwangCnt === 0) isGwangBak = true;
        }

        if (result === 'USER') {
            finalScore = gameState.myScore; if(gameState.myGoCount > 0) finalScore += gameState.myGoCount;
            if(isMungTa) finalScore *= 2; if(isGwangBak) finalScore *= 2; 
            if (gameState.oppGoCount > 0) { finalScore *= 2; reactOpponent('gobak'); text = `<div>ÎÇòÏùò ÏäπÎ¶¨! <span class="gobak-text">(ÏÉÅÎåÄ Í≥†Î∞ï x2)</span></div>`; } 
            else { text = `<div>ÎÇòÏùò ÏäπÎ¶¨!</div>`; }
            if (gameState.myScore >= 15 && isGwangBak) text += `<div><span style="color:red; font-size:1.2em;">Ïò§Í¥ë(15Ï†ê)!</span></div>`;
            if (isMungTa) text += `<div><span style="color:orange;">(Î©çÌÖÖÍµ¨Î¶¨ 2Î∞∞!)</span></div>`;
            if (isGwangBak) text += `<div><span style="color:cyan;">(ÏÉÅÎåÄ Í¥ëÎ∞ï 2Î∞∞!)</span></div>`;

            money = finalScore * 1000; myTotalMoney += money; characterStats[gameState.currentOpponentId].money -= money;
            text += `<div>${finalScore}Ï†ê (${gameState.myGoCount}Í≥†) = ${money.toLocaleString()}Ïõê</div>`; 
            playSound('win'); reactOpponent('user_win'); 
        
        } else if (result === 'OPP') {
            finalScore = gameState.oppScore; if(gameState.oppGoCount > 0) finalScore += gameState.oppGoCount;
            if(isMungTa) finalScore *= 2; if(isGwangBak) finalScore *= 2;
            if (gameState.myGoCount > 0) { finalScore *= 2; text = `<div>ÏÉÅÎåÄÎ∞© ÏäπÎ¶¨.. <span class="gobak-text">(ÎÇ¥ Í≥†Î∞ï x2)</span></div>`; } 
            else { text = `<div>ÏÉÅÎåÄÎ∞© ÏäπÎ¶¨..</div>`; }
            if (gameState.oppScore >= 15 && isGwangBak) text += `<div><span style="color:red; font-size:1.2em;">ÏÉÅÎåÄ Ïò§Í¥ë!</span></div>`;
            if (isMungTa) text += `<div><span style="color:orange;">(Î©çÌÖÖÍµ¨Î¶¨ 2Î∞∞!)</span></div>`;
            if (isGwangBak) text += `<div><span style="color:cyan;">(ÎÇ¥ Í¥ëÎ∞ï 2Î∞∞..)</span></div>`;

            money = finalScore * 1000; characterStats[gameState.currentOpponentId].money += money; myTotalMoney -= money;
            text += `<div>${finalScore}Ï†ê (ÎÇ¥Îèà -${money.toLocaleString()}Ïõê)</div>`; 
            playSound('fail'); reactOpponent('user_lose'); 
        } else { 
            text = "<div>ÎÇòÍ∞ÄÎ¶¨</div><div>Ï†êÏàòÍ∞Ä ÏóÜÏäµÎãàÎã§.</div>"; playSound('fail'); reactOpponent('nagari');
        }
        board.innerHTML = text; board.style.display = 'flex'; updateMoneyDisplay(); gameState.currentTurn = 'END'; 
    }
    function showEffect(text) { const el = document.getElementById('effect-text'); el.innerText = text; el.style.animation = 'none'; el.offsetHeight; el.style.animation = 'pop-text 1s ease-out forwards'; }
    function playSound(name) { const audio = document.getElementById('snd-' + name); if(audio) { audio.currentTime=0; audio.play(); } }
</script>
</body>
</html>